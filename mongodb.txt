# NOTE: some mongo clients require you to quote your keys


# 'uses the db', if the db does not exist, it creates it
use <db_name>

# shows the db you are currently in
db

db.createUser({
  user: "manyu",
  password: "1234",
  roles: ["readWrite", "dbAdmin"]
})

# create a collection named customers
db.createCollection('customers');

# show collections in db
show collections

# insert document into customers collection
db.customers.insert({
  first_name: "John",
  last_name: "Doe"
});
# insert multiple documents into customers collection
db.customers.insert([
{
  first_name: "John",
  last_name: "Doe"
},
{
  first_name: "Steven",
  last_name: "Smith"
},
{
  first_name: "Joan",
  last_name: "Johnson",
  gender: "female"
}
]);

# view all docs in customers collection
db.customers.find();

# prettify/format the output of a find
db.customers.find().pretty();

# update a document, you have to specify EVERY FIELD in an update even if your not changing a field
db.customers.update({first_name: "John"}, {first_name: "John", last_name: "Doe", gender: "male"});

# update a document using the $set operator so that we dont have to specify every field when adding a new field or setting an old field to a new value
db.customers.update({first_name: "Steven"}, {$set:{age: 45}});

# increment a number field by 5
db.customers.update({first_name: "Steven"}, {$inc:{age: 5}});

# remove a field from a document, 1 is a dummy value here
db.customers.update({first_name: "Steven"}, {$unset:{age: 1}});

# update does not update a document if it can not find it
db.customers.update({first_name: "Mary"}, {first_name: "Mary", last_name: "Samson"});

# adding upsert option to make mongo add the document if it does not exist for an update
db.customers.update({first_name: "Mary"}, {first_name: "Mary", last_name: "Samson"}, {upsert: true});

# rename the key gender to sex for documents with a first_name of "Steven"
db.customers.update({first_name: "Steven"}, {$rename: {"gender": "sex"}});

# remove documents from collection with the option of removing only the first match
db.customers.remove({first_name: "Steven"}, {justOne: true});

# FIND EXAMPLES BEGIN

db.customers.find({$or: [{first_name: "Sharon"}, {first_name: "Troy"}]});

# comparsion operators: $lte?, gte?
# everyone that is under the age of 40
db.customers.find({{age: {$lt: 40}}});

# nested key filter
db.customers.find({"address.city": "Boston"});

# this check will also check if the membership array contains the given value.
db.customers.find({membership: "mem1"});

# FIND EXAMPLES END

# sorting find results ascending order last name
db.customers.find({membership: "mem1"}).sort({last_name: 1});

# sorting find results descending order last name
db.customers.find({membership: "mem1"}).sort({last_name: -1});

# count the number of matches from a find
db.customers.find().count();

# set a limit of 4 documents from a find
db.customers.find().limit(4);

# for each
db.customers.find().forEach(function(doc) {print("Customer Name: " + doc.first_name)});


# AGGREGATION BEGIN

# aggregation is made of a 'pipeline' of steps to perform

# how many toothbrushes were sold
db.purchase_orders.count({product: "toothbrush"});

# Find a list of all products sold, returns a list of strings representing products
db.purchase_orders.distint("product");

# Find the total amount of money spent by each customer
db.purchase_orders.aggregate([
  {$match: {}}, # matches every entry in the collection, aka: no filter
  # {$match: {customer: {$in: ["Mike", "Karen"]}}}, # matches customers with the name of Mike or Karen
  # the {_id:..., total:...} below defines the structure we want the data returned in
  {$group: {_id: "$customer", total: {$sum: "$total"}}}, # group by the customer (_id is treated as unique by mongo) and sum the totals together for each customer
  {$sort: {total: -1}} # sort the results by total in descending order
]);

# like a sql LEFT OUTER JOIN = LEFT JOIN = JOIN
db.purchase_orders.aggregate([
  {$match: {}},
  {$group: {_id: "$customer", total: {$sum: "$total"}}},
  {
   $lookup:
     {
       # must be a collection from the same db and cannot be sharded
       from: <collection to join>,
       # comparsion of localField and foreignField is by strict equality, the field for either/both localField foreignField can have a value that is an array. it will be a contains check in that case
       localField: <field from the input documents>,
       foreignField: <field from the documents of the "from" collection>,
       # the foreign collection with have its documents that match placed in an array under the key name specified to as. NOTE: if the field existed before, it will be overridden after this.
       as: <output array field>
     }
  }
]);

# AGGREGATION END
